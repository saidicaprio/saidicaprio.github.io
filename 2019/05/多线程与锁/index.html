<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>iOS中的多线程与锁 | Sai&#39;s Cabin</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="Hi, I&#39;m SaiDicaprio, a iOS Developer from China.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="iOS中的多线程与锁 | Sai&#39;s Cabin">
    <meta name="twitter:description" content="Hi, I&#39;m SaiDicaprio, a iOS Developer from China.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="iOS中的多线程与锁 | Sai&#39;s Cabin">
    <meta property="og:description" content="Hi, I&#39;m SaiDicaprio, a iOS Developer from China.">

    
    <meta name="author" content="贺嘉炜">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Sai&#39;s Cabin" href="/atom.xml">
    

    <link rel="canonical" href="https://saidicaprio.com/2019/05/多线程与锁/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Sai&#39;s Cabin 的主页"><img src="/images/avatar.jpg" width="80" alt="Sai&#39;s Cabin logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sai&#39;s Cabin">Sai&#39;s Cabin</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">落月摇情满江树</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">Hi, I'm SaiDicaprio, a iOS Developer from China.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/">首页</a></li>
            
              <li class="navigation__item"><a href="./aboutme">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/hjw6160602" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-blue"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-05-17T08:52:02.000Z" class="post-list__meta--date date">2019-05-17</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/能工巧匠集/">能工巧匠集</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">iOS中的多线程与锁</h1>
  </header>

  <section class="post">
    <h2 id="一、-iOS中的多线程方案"><a href="#一、-iOS中的多线程方案" class="headerlink" title="一、 iOS中的多线程方案"></a>一、 iOS中的多线程方案</h2><p><img src="https://willjayh.oss-cn-shanghai.aliyuncs.com/test/1558083284.jpg" width="700/"></p>
<h3 id="1-GCD"><a href="#1-GCD" class="headerlink" title="1.GCD"></a>1.GCD</h3><p>有2个概念需要了解：同步/步、队列</p>
<h4 id="同步和异步主要影响：能不能开启新的线程"><a href="#同步和异步主要影响：能不能开启新的线程" class="headerlink" title="同步和异步主要影响：能不能开启新的线程"></a>同步和异步主要影响：能不能开启新的线程</h4><ul>
<li>同步：在当前线程中执行任务，不具备开启新线程的能力</li>
<li>异步：在新的线程中执行任务，具备开启新线程的能力</li>
</ul>
<h4 id="并发和串行主要影响：任务的执行方式"><a href="#并发和串行主要影响：任务的执行方式" class="headerlink" title="并发和串行主要影响：任务的执行方式"></a>并发和串行主要影响：任务的执行方式</h4><ul>
<li>并发：多个任务并发（同时）执行</li>
<li>串行：一个任务执行完毕后，再执行下一个任务</li>
</ul>
<p><img src="https://willjayh.oss-cn-shanghai.aliyuncs.com/test/1558082201.jpg" width="600/"></p>
<h4 id="如何用gcd实现以下功能"><a href="#如何用gcd实现以下功能" class="headerlink" title="如何用gcd实现以下功能"></a>如何用<code>gcd</code>实现以下功能</h4><p>异步并发执行任务A、任务B<br>等任务A、任务B都执行完毕后，再回到主线程执行任务C</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列组</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="comment">// 创建并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加异步任务</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务A-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务B-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等前面的任务执行完毕后，会自动执行这个任务</span></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务C-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h5><p>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源<br>比如多个线程访问同一个对象、同一个变量、同一个文件</p>
<p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</p>
<h2 id="二、-iOS中的锁"><a href="#二、-iOS中的锁" class="headerlink" title="二、 iOS中的锁"></a>二、 iOS中的锁</h2><ol>
<li><code>OSSpinLock</code> 自旋锁</li>
<li><code>os_unfair_lock</code></li>
<li><code>pthread_mutex</code> 互斥所</li>
<li><code>dispatch_semaphore</code> 信号量</li>
<li><code>dispatch_queue</code>(<code>DISPATCH_QUEUE_SERIAL</code>)</li>
<li><code>NSLock</code></li>
<li><code>NSRecursiveLock</code></li>
<li><code>NSCondition</code></li>
<li><code>NSConditionLock</code></li>
<li><code>@synchronized</code></li>
</ol>
<h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a><code>OSSpinLock</code></h4><p>”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>
<p>目前已经不再安全，可能会出现优先级反转问题，如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p>
<blockquote>
<p>需要导入头文件<code>#import &lt;libkern/OSAtomic.h&gt;</code></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">OSSpinLock lock = OSSPINLOCK_INIT;</span><br><span class="line"><span class="comment">// 尝试加锁(如果需要等待就不加锁，直接返回false如果不需要等待就加锁，返回true)</span></span><br><span class="line"><span class="keyword">bool</span> result = OSSpinLockTry(&amp;lock);</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p><strong><code>OSSpinLock</code> 可能会引发优先级反转 从iOS10之后开始推荐改为–&gt; os_unfair_lock</strong></p>
<h4 id="os-unfair-lock用于取代不安全的OSSpinLock-，从iOS10开始才支持"><a href="#os-unfair-lock用于取代不安全的OSSpinLock-，从iOS10开始才支持" class="headerlink" title="os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持"></a><code>os_unfair_lock</code>用于取代不安全的OSSpinLock ，从iOS10开始才支持</h4><p>从汇编底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等，也就是说从本质上来说<code>os_unfair_lock</code>其实类似于互斥锁，</p>
<blockquote>
<p>需要导入头文件<code>#import &lt;os/lock.h&gt;</code></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line">os_unfair_lock_trylock(&amp;lock);</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">os_unfair_lock_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p><code>os_unfair_lock</code> 是一个 <code>low level lock</code>，其特点是如果等不到锁，就会进入睡眠。</p>
<h4 id="mutex-互斥锁"><a href="#mutex-互斥锁" class="headerlink" title="mutex 互斥锁"></a><code>mutex</code> 互斥锁</h4><p>等待锁的线程会处于休眠状态</p>
<blockquote>
<p>需要导入头文件#import &lt;pthread.h&gt;</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// 销毁相关资源</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">pthread_mutex_destroy(&amp; mutex);</span><br></pre></td></tr></table></figure>
<h4 id="pthread-mutex-来实现递归锁"><a href="#pthread-mutex-来实现递归锁" class="headerlink" title="pthread_mutex 来实现递归锁"></a><code>pthread_mutex</code> 来实现递归锁</h4><p>递归锁虽然可以允许重复加锁，但是必须保证在同一个线程上来确保证线程安全。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(mutex, &amp;attr);</span><br></pre></td></tr></table></figure>
<p><strong><code>pthread_mutex</code> 递归锁的使用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 线程1：test（+-）</span><br><span class="line">        test（+-）</span><br><span class="line">         test（+-）</span><br><span class="line"> 线程2：test（等待）</span><br><span class="line"> */</span><br><span class="line">- (void) test &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    static int count = 0;</span><br><span class="line">    if (count &lt; 10) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        [self test];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-mutex-来实现条件锁"><a href="#pthread-mutex-来实现条件锁" class="headerlink" title="pthread_mutex 来实现条件锁"></a><code>pthread_mutex</code> 来实现条件锁</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"><span class="comment">// NULL代表使用默认属性</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 初始化条件</span></span><br><span class="line">pthread_cond_t condition;</span><br><span class="line">pthread_cond_init(&amp;condition, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 等待条件(进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁)</span></span><br><span class="line">pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line"><span class="comment">// 激活一个等待该条件的线程</span></span><br><span class="line">pthread_cond_signal(&amp;condition);</span><br><span class="line"><span class="comment">// 激活所有等待该条件的线程</span></span><br><span class="line">pthread_cond_brodcast(&amp;condition);</span><br><span class="line"><span class="comment">// 销毁相关资源</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">pthread_cond_destroy(&amp;condition);</span><br></pre></td></tr></table></figure>
<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a><code>NSLock</code></h4><p><strong>其实<code>NSLock</code>是对<code>mutex</code>普通锁的封装</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>其中<code>NSLoking</code>协议的定义如下</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSLocking</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lock;</span><br><span class="line">- (<span class="keyword">void</span>)unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>初始化锁 <code>NSLock *lock = [[NSLock alloc] init];</code></p>
<p><strong><code>NSRecursiveLock</code></strong></p>
<p>本质上也是对<code>mutex</code>递归锁的封装，<code>API</code>跟<code>NSLock</code>基本一致</p>
<h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p>本质上是对<code>mutex</code>和<code>cond</code>的封装</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSCondition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wait;</span><br><span class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="keyword">void</span>)signal;</span><br><span class="line">- (<span class="keyword">void</span>)broadcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong><code>NSCondition</code>在生产者-消费者模式下的使用方式</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者-消费者模式</span></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__remove &#123;</span><br><span class="line">    [<span class="keyword">self</span>.condition lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__remove - begin"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        [<span class="keyword">self</span>.condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"删除了元素"</span>);</span><br><span class="line">    [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__add &#123;</span><br><span class="line">    [<span class="keyword">self</span>.condition lock];</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加了元素"</span>);</span><br><span class="line">    <span class="comment">// 信号</span></span><br><span class="line">    [<span class="keyword">self</span>.condition signal];</span><br><span class="line">    <span class="comment">// 广播</span></span><br><span class="line"><span class="comment">//    [self.condition broadcast];</span></span><br><span class="line">    [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a><code>NSConditionLock</code></h4><p><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSConditionLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCondition:(<span class="built_in">NSInteger</span>)condition <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> condition;</span><br><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="keyword">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>NSConditionLock</code>的使用方式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.conditionLock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__one) object:<span class="literal">nil</span>] start];</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__two) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__one &#123;</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__one"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__two &#123;</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__two"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="semaphore——-信号量"><a href="#semaphore——-信号量" class="headerlink" title="semaphore—— 信号量"></a><code>semaphore</code>—— 信号量</h4><p>信号量的初始值，可以用来控制线程并发访问的最大数量<br>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量的初始化</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line"><span class="comment">// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">// 让信号量的值+1</span></span><br><span class="line">dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br></pre></td></tr></table></figure>
<p><strong>直接使用GCD的串行队列，也是可以实现线程同步的</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"lock_queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_syns(queue, ^&#123;</span><br><span class="line">    <span class="comment">//任务</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a><code>@synchronized</code></h3><p><strong><code>@synchronized</code>其实是对<code>mutex</code>递归锁的封装</strong></p>
<p>源码查看：<code>objc4</code>中的<code>objc-sync.mm</code>文件<br><code>@synchronized(obj)</code>内部会生成<code>obj</code>对应的递归锁，然后进行加锁、解锁操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(obj) &#123;</span><br><span class="line">     <span class="comment">// 任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其底层使用到了哈希表这种数据结构，会将传入的对象作为<code>key</code>，找到对应的<code>value</code>，然后取出<code>SyncData</code>结构里的data字段，取出内部的锁<code>mutex</code>。</p>
<blockquote>
<p>@synchronized是一个递归锁</p>
</blockquote>
<h3 id="各种锁之间的性能对比"><a href="#各种锁之间的性能对比" class="headerlink" title="各种锁之间的性能对比"></a>各种锁之间的性能对比</h3><p><img src="https://willjayh.oss-cn-shanghai.aliyuncs.com/test/1558091574.jpg" width="600/"></p>
<h4 id="性能从高到低排序"><a href="#性能从高到低排序" class="headerlink" title="性能从高到低排序"></a>性能从高到低排序</h4><ol>
<li><code>os_unfair_lock</code></li>
<li><code>OSSpinLock</code></li>
<li><code>dispatch_semaphore</code></li>
<li><code>pthread_mutex</code></li>
<li><code>dispatch_queue</code></li>
<li><code>NSLock</code></li>
<li><code>NSCondition</code></li>
<li><code>pthread_mutex</code>(<code>recursive</code>)</li>
<li><code>NSRecursiveLock</code></li>
<li><code>NSConditionLock</code></li>
<li><code>@synchronized</code></li>
</ol>
<h3 id="自旋锁和互斥所的对比"><a href="#自旋锁和互斥所的对比" class="headerlink" title="自旋锁和互斥所的对比"></a>自旋锁和互斥所的对比</h3><h4 id="什么情况使用自旋锁比好？"><a href="#什么情况使用自旋锁比好？" class="headerlink" title="什么情况使用自旋锁比好？"></a>什么情况使用自旋锁比好？</h4><ul>
<li>预计线程等待锁的时间很短</li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>
<li><code>CPU</code>资源不紧张</li>
<li>多核处理器</li>
</ul>
<h4 id="什么情况使用互斥锁比较好？"><a href="#什么情况使用互斥锁比较好？" class="headerlink" title="什么情况使用互斥锁比较好？"></a>什么情况使用互斥锁比较好？</h4><ul>
<li>预计线程等待锁的时间较长</li>
<li>单核处理器</li>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
<h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a><code>atomic</code></h3><p>给属性加上<code>atomic</code>修饰符，代表了属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就保证<code>setter</code>和<code>getter</code>内部是线程同步的</p>
<p><strong><code>atomic</code>用于保证属性<code>setter</code>、<code>getter</code>的原子性操作，相当于在<code>getter</code>和<code>setter</code>内部加了线程同步的锁</strong></p>
<p>可以参考源码<code>objc4</code>的<code>objc-accessors.mm</code>，它并不能保证使用属性的过程是线程安全的。</p>
<h3 id="读写IO优化"><a href="#读写IO优化" class="headerlink" title="读写IO优化"></a>读写IO优化</h3><p><strong>思考如何实现以下场景：</strong></p>
<p>同一时间，只能有1个线程进行写的操作，同一时间，允许有多个线程进行读的操作，同一时间，不允许既有写的操作，又有读的操作。</p>
<h5 id="上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作"><a href="#上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作" class="headerlink" title="上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作"></a>上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作</h5><p>iOS中的实现方案</p>
<ul>
<li><code>pthread_rwlock</code>：读写锁</li>
<li><code>dispatch_barrier_async</code>：异步栅栏调用</li>
</ul>
<h4 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a><code>pthread_rwlock</code></h4><h5 id="等待锁的线程会进入休眠"><a href="#等待锁的线程会进入休眠" class="headerlink" title="等待锁的线程会进入休眠"></a>等待锁的线程会进入休眠</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 读-加锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line"><span class="comment">// 读-尝试加锁</span></span><br><span class="line">pthread_rwlock_tryrdlock(&amp;lock);</span><br><span class="line"><span class="comment">// 写-加锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line"><span class="comment">// 写-尝试加锁</span></span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_rwlock__unlock(&amp;lock);</span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>
<h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a><code>dispatch_barrier_async</code></h4><p>这个函数传入的并发队列必须是自己通过<code>dispatch_queue_cretate</code>创建的<br>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于<code>dispatch_async</code>函数的效果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"rw_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^ &#123;</span><br><span class="line">	<span class="comment">//读操作</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^ &#123;</span><br><span class="line">	<span class="comment">//写操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2019/05/性能优化/" title="性能优化">性能优化</a></h2>
                <p class="excerpt">
                
                1.卡顿优化卡顿优化可以从两个层面切入CPU与GPU
1.1 CPU卡顿优化
尽量使用轻量级的对象，比如用不到时间处理的地方，可以考虑使用CALayer代替UIView
不要频繁地调用UIView的相关属性，比如frame、bounds、tansform等属性，尽量减少不必要的修改
尽量提前计算好布
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-05-22T04:21:09.000Z" class="post-list__meta--date date">2019-05-22</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/能工巧匠集/">能工巧匠集</a>
</span><a class="btn-border-small" href="/2019/05/性能优化/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2019/05/深入理解Runtime/" title="深入理解Runtime">深入理解Runtime</a></h2>
                <p class="excerpt">
                
                rw = cls-&amp;gt;data()
存储了当前类在编译期就已经确定的属性、方法以及遵循的协议
12345678910111213141516struct class_ro_t &amp;#123;      uint32_t flags;    uint32_t instanceStart;    ui
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-05-17T08:52:02.000Z" class="post-list__meta--date date">2019-05-17</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/能工巧匠集/">能工巧匠集</a>
</span><a class="btn-border-small" href="/2019/05/深入理解Runtime/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2023 - 本站使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题,
        由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
